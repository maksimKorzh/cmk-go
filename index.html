<!DOCTYPE html>
<html lang="en"i style="touch-action: none;">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="user-scalable=0">
  <meta name="description" content="Game of Go - A progressive web application that runs in a web browser or as a native Android application. Improve your Go/Weiqi/Baduk skills by playing this app.">
  <meta name="keyword" content="go, weiqi, baduk, game of go, katago, neural net, web browser, android application, free, ad-free">
  <base href="cmkgo">
  <link rel="manifest" href="/cmkgo/manifest.json">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background-color: #111;
      color: #aaa;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      -webkit-user-select: none; /* Chrome, Safari, and Opera */
      -moz-user-select: none;    /* Firefox */
      -ms-user-select: none;     /* Internet Explorer/Edge */
      user-select: none;         /* Standard syntax */
    }
    
    .container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      width: 100%;
      flex-direction: column;
    }
    
    button {
     -webkit-tap-highlight-color: transparent;
      width: 100%;
      padding: 10px;
      background-color: #111;
      color: #aaa;
      border: 1px solid #555;
      border-radius: 5px;
      cursor: pointer;
      font-size: 30px;
    }
    
    button:hover {
      background: #444;
    }
    
    button:active {
      background-color: black;
      color: white;
    }
  </style>
  <title>Go</title>
</head>
<body>
  <div id="controls"></div>
  <div class="container"><div id="goban"></div></div>
  <div id="stats" style="font-size: 38px; margin-bottom: 2%;"></div>
  <script src="/cmkgo/tfjs/tf.js"></script>
  <script> // gui.js
    var canvas, ctx, cell;
    var editMode = 0;
    var gameOver = 0;
    var sidePoints = [];
    var countPoints = [];
    const bgImage = new Image();
    const blackStoneImage = new Image();
    const whiteStoneImage = new Image();
    const moveSound = new Audio('./assets/112-2052.wav');
    bgImage.src = './assets/board_fox.png';
    blackStoneImage.src = './assets/stone_b_fox.png';
    whiteStoneImage.src = './assets/stone_w_fox.png';
    let imagesLoaded = false;
    bgImage.onload = blackStoneImage.onload = whiteStoneImage.onload = () => {
      if (bgImage.complete && blackStoneImage.complete && whiteStoneImage.complete) {
        imagesLoaded = true;
      }
    };

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/cmkgo/service-worker.js')
    }

    function isFirefoxMobile() {
      const ua = navigator.userAgent;
      // Firefox on Android
      const firefoxAndroid = /Android/i.test(ua) && /Firefox/i.test(ua);
      // Firefox on iOS
      const firefoxiOS = /iPhone|iPad|iPod/i.test(ua) && /FxiOS/i.test(ua);
      return firefoxAndroid || firefoxiOS;
    }

    if (isFirefoxMobile()) tf.setBackend('cpu');
      else {
      tf.setBackend('webgl').then(() => {
        if (tf.getBackend() !== 'webgl') {
          tf.setBackend('cpu');
          console.log('Using CPU backend')
        } else  console.log('Using WebGL backend')
      });
    }
    
    function drawBoard() {
      cell = canvas.width / (size-2);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      for (let i = 0; i < size-2; i++) {
        const x = i * cell + cell / 2;
        const y = i * cell + cell / 2;
        let offset = cell * 2 - cell / 2 - cell;
        ctx.moveTo(offset, y);
        ctx.lineTo(canvas.width - offset, y);
        ctx.moveTo(x, offset);
        ctx.lineTo(x, canvas.height - offset);
      };
      ctx.lineWidth = 1;
      ctx.stroke();
      for (let row = 0; row < size-2; row++) {
        for (let col = 0; col < size-2; col++) {
          let sq = (row+1) * size + (col+1);
          let starPoints = {
             9: [36, 38, 40, 58, 60, 62, 80, 82, 84],
            13: [64, 67, 70, 109, 112, 115, 154, 157, 160],
            19: [88, 94, 100, 214, 220, 226, 340, 346, 352]
          }
          if ([9, 13, 19].includes(size-2) && starPoints[size-2].includes(sq)) {
            ctx.beginPath();
            ctx.arc(col * cell+(cell/4)*2, row * cell +(cell/4)*2, cell / 6 - 2, 0, 2 * Math.PI);
            ctx.fillStyle = 'black';
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.stroke();
          }
          if (board[sq] == 7) continue;
          const stoneImage = board[sq] == 1 ? blackStoneImage : whiteStoneImage;
          if (board[sq]) {
            ctx.drawImage(
              stoneImage,
              col * cell + cell / 2 - cell / 2,
              row * cell + cell / 2 - cell / 2,
              cell,
              cell
            );
          }
          if (sq == userMove) {
            let color = board[sq] == 1 ? 'white' : 'black';
            ctx.beginPath();
            ctx.arc(col * cell+(cell/4)*2, row * cell +(cell/4)*2, cell / 5 - 2, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }
      }
    }
    
    function userInput(event) {
      let rect = canvas.getBoundingClientRect();
      let mouseX = event.clientX - rect.left;
      let mouseY = event.clientY - rect.top;
      let col = Math.floor(mouseX / cell);
      let row = Math.floor(mouseY / cell);
      let sq = (row+1) * size + (col+1);
      if (board[sq]) {
        if (gameOver) {
          board[sq] = EMPTY;
          drawBoard();
        } return;
      }
      if (!setStone(sq, side, true)) return;
      drawBoard();
      moveSound.play();
      if (!gameOver) setTimeout(function() { playMove(); }, 200)
    }
    
    function resizeCanvas() {
      if (window.innerWidth >= window.innerHeight) window.innerWidth = 800;
      canvas.width = window.innerWidth-20;
      canvas.height = canvas.width;
      drawBoard();
      document.getElementById('controls').style = 'display: flex; height: 6vh; gap: 5px; width: ' + (canvas.width+4) + 'px;';
    }
    
    function downloadSgf() {
      const element = document.createElement('a');
      const file = new Blob([saveSgf()], { type: 'text/plain' });
      element.href = URL.createObjectURL(file);
      element.download = 'game.sgf';
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    
    function evaluate() { /* Count captures stones difference */
      let eval = 0;
      let blackStones = 0;
      let whiteStones = 0;
      for (let sq = 0; sq < size ** 2; sq++) {
        if (!board[sq] || board[sq] == OFFBOARD) continue;
        if (board[sq] == BLACK) blackStones += 1;
        if (board[sq] == WHITE) whiteStones += 1;
      } eval += (blackStones - whiteStones);
      return (side == BLACK) ? eval : -eval;
    }

    function territory(sq) { /* Count territory, returns [side, points]*/
      stone = board[sq];
      if (stone == OFFBOARD) return OFFBOARD;
      if (stone == EMPTY) {
        block.push(sq);
        countPoints.push(sq);
        board[sq] |= MARKER;
        for (let offset of [1, size, -1, -size]) territory(sq+offset);
      } else if (stone != MARKER) {
        sidePoints.push(stone);
      } if (!sidePoints.length) return [EMPTY, countPoints.length];
      else if (sidePoints.every((element) => element == sidePoints[0]))
        return [sidePoints[0], countPoints.length];
      else return [EMPTY, countPoints.length];
    }
    
    function score() { /* Scores game, returns points [empty, black, white]*/
      let scorePosition = [0, 0, 0];
      for (let sq = 0; sq < size ** 2; sq++) {
        if (board[sq]) continue;
        let result = territory(sq);
        scorePosition[result[0]] += result[1];
        sidePoints = [];
        countPoints = [];
      } restoreBoard();
      let prisoners = (side == BLACK ? evaluate(): -evaluate());
      if (prisoners > 0) scorePosition[BLACK] += prisoners;
      if (prisoners < 0) scorePosition[WHITE] += Math.abs(prisoners);
      scorePosition[WHITE] += komi;
      return scorePosition;
    }

    function handleGo() {
      if (!gameOver) {
        if (editMode) handleMode();
        alert('Please press "PASS" to finish the game first');
        return;
      }
      initGoban();
      drawBoard();
      gameOver = 0;
      editMode = 0;
      document.getElementById('stats').innerHTML = 'Japanese rules, Komi 6.5';
    }
    
    function handleEval() {
      if (!gameOver) {
        alert('Game is scored after 2 consecutive passes');
        return;
      }
      let result = score()
      document.getElementById('stats').innerHTML = 'Press PLAY to play again';
      result = `Black: ${result[BLACK]}, White: ${result[WHITE]}, Dame: ${result[EMPTY]}`;
      setTimeout(function() { alert('Score:\n' + result); }, 100);
    }

    function handlePass() {
      if (!gameOver) {
        if (editMode) passMove();
        else {
          (async () => {
            if (!moveHistory.slice(-1).move) {
              passMove();
              passMove();
              if (!moveHistory.slice(-1).move && !moveHistory.slice(-2).move) {
                alert('Remove dead stones, fill dame and press EVAL');
                gameOver = 1;
              }
            }
          })();    
        }
      }
    }
    
    function handleMove() {
      if (!gameOver) playMove(1)
    }
    
    function handleUndo() {
      if (!gameOver) {
        undoMove();
        drawBoard();
      }
    }
    
    function handleMode() {
      if (!gameOver) {
        editMode ^= 1;
        document.getElementById('stats').innerHTML = editMode ? 'EDIT' : 'PLAY';
        drawBoard();
      }
    }
    
    function handleSave() {
      downloadSgf();
    }
    
    function initGUI() {
      let container = document.getElementById('goban');
      canvas = document.createElement('canvas');
      canvas.style = 'border: 2px solid black;';
      container.appendChild(canvas);
      canvas.addEventListener('click', userInput);
      ctx = canvas.getContext('2d');
      document.getElementById('controls').innerHTML = `
        <button onclick="handleGo();">PLAY</button>
        <button onclick="handlePass();">PASS</button>
        <button onclick="handleMove();">MOVE</button>
        <button onclick="handleUndo();">UNDO</button>
        <button onclick="handleMode();">MODE</button>
        <button onclick="handleEval();">EVAL</button>
        <button onclick="handleSave();">SAVE</button>
      `;
      window.addEventListener('resize', resizeCanvas);
      initGoban();
      resizeCanvas();
      document.getElementById('stats').innerHTML = 'Japanese rules, Komi 6.5';
    }
  </script>
  <script> // goban.js
    var tf;
    if (typeof(module) != 'undefined') {
      (async () => {
        process.env.TF_CPP_MIN_LOG_LEVEL = '2';
        tf = require('@tensorflow/tfjs-node');
        (async () => {
          try {
            model = await tf.loadLayersModel(`file://model/model.json`);
          } catch (e) {}
        })();
      })();
    }
    
    if (typeof(document) != 'undefined') {
      (async () => {
        document.getElementById('stats').innerHTML = 'Loading neural nets, please wait...';
        model = await tf.loadLayersModel('https://maksimkorzh.github.io/cmkgo/model/model.json');
        setTimeout(function() {initGUI();}, 100);
      })();
    }
    
    const inputBufferChannels = 16;
    const inputFeatures = 19 * 19 * inputBufferChannels;
    
    const EMPTY = 0
    const BLACK = 1
    const WHITE = 2
    const MARKER = 4
    const OFFBOARD = 7
    const LIBERTY = 8
    
    var board = [];
    var moveHistory = [];
    var komi = 6.5;
    var size = 21;
    var side = BLACK;
    var liberties = [];
    var block = [];
    var ko = EMPTY;
    var bestMove = EMPTY;
    var userMove = EMPTY;
    var moveCount = EMPTY;
    var level = 1;
    
    function clearBoard() {
      board = [];
      moveHistory = [];
      liberties = [];
      block = [];
      liberties = [];
      block = [];
      side = BLACK;
      ko = EMPTY;
      bestMove = EMPTY;
      userMove = EMPTY;
      moveCount = EMPTY;
      level = 1;
      for (let sq = 0; sq < size ** 2; sq++) {
        switch (true) {
          case (sq < size):
          case (sq >= (size ** 2 - size)):
          case (!(sq % size)):
            board[sq] = OFFBOARD;
            board[sq-1] = OFFBOARD;
            break;
          default: board[sq] = 0;
        }
      }
    }
    
    function printBoard() {
      let pos = '';
      let chars = '.XO    #';
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          let sq = row * size + col;
          pos += ' ' + chars[board[sq]];
        } pos += '\n'
      } console.log(pos);
      return pos;
    }
    
    function setStone(sq, color, user) {
      if (board[sq] != EMPTY) {
        if (user) alert("Illegal move!");
        return false;
      } else if (sq == ko) {
        if (user) alert("Ko!");
        return false;
      } let old_ko = ko;
      ko = EMPTY;
      board[sq] = color;
      captures(3 - color, sq);
      countLiberties(sq, color);
      let suicide = liberties.length ? false : true; 
      restoreBoard();
      if (suicide) {
        board[sq] = EMPTY;
        ko = old_ko;
        moveCount--;
        if (user) alert("Suicide move!");
        return false;
      } 
      side = 3 - side;
      userMove = sq;
      moveHistory.push({
        'ply': moveCount+1,
        'side': (3-color),
        'move': sq,
        'board': JSON.stringify(board),
        'ko': ko
      });
      moveCount = moveHistory.length-1;
      return true;
    }
    
    function passMove() {
      moveHistory.push({
        'ply': moveCount+1,
        'side': (3-side),
        'move': EMPTY,
        'board': JSON.stringify(board),
        'ko': ko
      });
      moveCount = moveHistory.length-1;
      ko = EMPTY;
      side = 3 - side;
    }
    
    function countLiberties(sq, color) {
      let stone = board[sq];
      if (stone == OFFBOARD) return;
      if (stone && (stone & color) && (stone & MARKER) == 0) {
        block.push(sq);
        board[sq] |= MARKER;
        for (let offset of [1, size, -1, -size]) countLiberties(sq+offset, color);
      } else if (stone == EMPTY) {
        board[sq] |= LIBERTY;
        liberties.push(sq);
      }
    }
    
    function restoreBoard() {
      block = []; liberties = []; sidePoints = [];
      for (let sq = 0; sq < size ** 2; sq++) {
        if (board[sq] != OFFBOARD) board[sq] &= 3;
      }
    }
    
    function captures(color, move) {
      for (let sq = 0; sq < size ** 2; sq++) {
        let stone = board[sq];
        if (stone == OFFBOARD) continue;
        if (stone & color) {
          countLiberties(sq, color);
          if (liberties.length == 0) clearBlock(move);
          restoreBoard()
        }
      }
    }
    
    function clearBlock(move) {
      if (block.length == 1 && inEye(move, 0) == 3-side) ko = block[0];
      for (let i = 0; i < block.length; i++)
        board[block[i]] = EMPTY;
    }
    
    function inEye(sq) {
      let eyeColor = -1;
      let otherColor = -1;
      for (let offset of [1, size, -1, -size]) {
        if (board[sq+offset] == OFFBOARD) continue;
        if (board[sq+offset] == EMPTY) return 0;
        if (eyeColor == -1) {
          if (board[sq+offset] <= 2) eyeColor = board[sq+offset];
          else eyeColor = board[sq+offset] - MARKER;
          otherColor = 3-eyeColor;
        } else if (board[sq+offset] == otherColor)
          return 0;
      } return eyeColor;
    }
    
    function isLadder(sq, color) {
      let libs = [];
      countLiberties(sq, color);
      libs = JSON.parse(JSON.stringify(liberties));
      restoreBoard();
      if (libs.length == 0) return 1;
      if (libs.length == 1) {
        board[libs[0]] = color;
        if (isLadder(libs[0], color)) return 1;
        board[libs[0]] = EMPTY;
      }
      if (libs.length == 2) {
        for (let move of libs) {
          board[move] = (3-color);
          if (isLadder(sq, color)) return move;
          board[move] = EMPTY;
        }
      }
      return 0;
    }
    
    function loadHistoryMove() {
      let move = moveHistory[moveCount];
      board = JSON.parse(move.board);
      side = move.side;
      ko = move.ko;
      userMove = move.move;
    }
    
    function undoMove() {
      if (moveCount == 0) return;
      moveCount--;
      moveHistory.pop();
      loadHistoryMove();
    }
    
    function firstMove() {
      moveCount = 0;
      loadHistoryMove();
    }
    
    function prevMove() {
      if (moveCount == 0) return;
      moveCount--;
      loadHistoryMove();
    }
    
    function prevFewMoves(few) {
      if (moveCount == 0) return;
      if ((moveCount - few) >= 0) moveCount -= few;
      else firstMove();
      loadHistoryMove();
    }
    
    function nextMove() {
      if (moveCount == moveHistory.length-1) return;
      moveCount++;
      loadHistoryMove();
    }
    
    function nextFewMoves(few) {
      if (moveCount == moveHistory.length-1) return;
      if ((moveCount + few) <= moveHistory.length-1) moveCount += few;
      else lastMove();
      loadHistoryMove();
    }
    
    function lastMove() {
      moveCount = moveHistory.length-1
      loadHistoryMove();
    }
    
    function getHistory() {
      return moveHistory;
    }
    
    function loadSgfMove(move) {
      if (move.length) {
        if (move.charCodeAt(2) < 97 || move.charCodeAt(2) > 115) return -1;
        let player = move[0] == 'B' ? BLACK : WHITE;
        let col = move.charCodeAt(2)-97;
        let row = move.charCodeAt(3)-97;
        let sq = (row+1) * 21 + (col+1);
        setStone(sq, player, false);
        return row * 19 + col;
      }
    }
    
    function loadSgf(sgf) {
      for (let move of sgf.split(';')) loadSgfMove(move);
      firstMove();
    }
    
    function saveSgf() {
      let sgf = '(';
      for (let item of moveHistory.slice(1, moveHistory.length)) {
        let col = item.move % size;
        let row = Math.floor(item.move / size);
        let color = item.side == BLACK ? 'W' : 'B';
        let coords = ' abcdefghijklmnopqrs';
        let move = coords[col] + coords[row];
        if (move == '  ') sgf += ';' + color + '[]'
        else sgf += ';' + color + '[' + move + ']';
      } sgf += ')'
      return sgf;
    }
    
    function enableLadders(binInputs) {
      let move = moveHistory[moveCount];
      boardCopy = JSON.parse(move.board);
      sideCopy = move.side;
      koCopy = move.ko;
      for (let y = 0; y < 19; y++) {
        for (let x = 0; x < 19; x++) {
          let sq_19x19 = (19 * y + x);
          let sq_21x21 = (21 * (y+1) + (x+1))
          let color = board[sq_21x21];
          if (color == BLACK || color == WHITE) {
            let libs_black = 0;
            let libs_white = 0;
            countLiberties(sq_21x21, BLACK);
            libs_black = liberties.length;
            restoreBoard();
            countLiberties(sq_21x21, WHITE);
            libs_white = liberties.length;
            restoreBoard();
            if (libs_black == 1 || libs_black == 2 || libs_white == 1 || libs_white == 2) {
              let laddered = isLadder(sq_21x21, color);
              if (laddered == 1) {
                binInputs[inputBufferChannels * sq_19x19 + 12] = 1.0;
                binInputs[inputBufferChannels * sq_19x19 + 13] = 1.0;
                binInputs[inputBufferChannels * sq_19x19 + 14] = 1.0;
              }
              else if (laddered > 1) {
                let col = laddered % size;
                let row = Math.floor(laddered / size);
                let workingMove = 19 * (row-1) + (col-1);
                binInputs[inputBufferChannels * workingMove + 15] = 1.0;
              }
            }
          }
        }
      }
      board = boardCopy;
      side = sideCopy;
      ko = koCopy;
    }
    
    function inputTensor() {
      let cmknet = side;
      let player = (3-side);
      const binInputs = new Float32Array(inputFeatures);
      for (let y = 0; y < 19; y++) {
        for (let x = 0; x < 19; x++) {
          let sq_19x19 = (19 * y + x);
          let sq_21x21 = (21 * (y+1) + (x+1))
          binInputs[inputBufferChannels * sq_19x19 + 0] = 1.0;
          if (board[sq_21x21] == cmknet) binInputs[inputBufferChannels * sq_19x19 + 1] = 1.0;
          if (board[sq_21x21] == player) binInputs[inputBufferChannels * sq_19x19 + 2] = 1.0;
          if (board[sq_21x21] == cmknet || board[sq_21x21] == player) {
            let libs_black = 0;
            let libs_white = 0;
            countLiberties(sq_21x21, BLACK);
            libs_black = liberties.length;
            restoreBoard();
            countLiberties(sq_21x21, WHITE);
            libs_white = liberties.length;
            restoreBoard();
            if (libs_black == 1 || libs_white == 1) binInputs[inputBufferChannels * sq_19x19 + 3] = 1.0;
            if (libs_black == 2 || libs_white == 2) binInputs[inputBufferChannels * sq_19x19 + 4] = 1.0;
            if (libs_black == 3 || libs_white == 3) binInputs[inputBufferChannels * sq_19x19 + 5] = 1.0;
          }
        }
      }
      if (ko != EMPTY) {
        let col = (ko % 21)-1;
        let row = Math.floor(ko / 21)-1;
        let sq_19x19 = row * 19 + col;
        binInputs[inputBufferChannels * sq_19x19 + 6] = 1.0;
      }
      let moveIndex = moveHistory.length-1;
      if (moveIndex >= 1 && moveHistory[moveIndex-1].side == player) {
        let prevLoc1 = moveHistory[moveIndex-1].move;
        let x = (prevLoc1 % 21)-1;
        let y = (Math.floor(prevLoc1 / 21))-1;
        if (prevLoc1) binInputs[inputBufferChannels * (19 * y + x) + 7] = 1.0;
        if (moveIndex >= 2 && moveHistory[moveIndex-2].side == cmknet) {
          let prevLoc2 = moveHistory[moveIndex-2].move;
          let x = (prevLoc2 % 21)-1;
          let y = (Math.floor(prevLoc2 / 21))-1;
          if (prevLoc2) binInputs[inputBufferChannels * (19 * y + x) + 8] = 1.0;
          if (moveIndex >= 3 && moveHistory[moveIndex-3].side == player) {
            let prevLoc3 = moveHistory[moveIndex-3].move;
            let x = (prevLoc3 % 21)-1;
            let y = (Math.floor(prevLoc3 / 21))-1;
            if (prevLoc3) binInputs[inputBufferChannels * (19 * y + x) + 9] = 1.0;
            if (moveIndex >= 4 && moveHistory[moveIndex-4].side == cmknet) {
              let prevLoc4 = moveHistory[moveIndex-4].move;
              let x = (prevLoc4 % 21)-1;
              let y = (Math.floor(prevLoc4 / 21))-1;
              if (prevLoc4) binInputs[inputBufferChannels * (19 * y + x) + 10] = 1.0;
              if (moveIndex >= 5 && moveHistory[moveIndex-5].side == player) {
                let prevLoc5 = moveHistory[moveIndex-5].move;
                let x = (prevLoc5 % 21)-1;
                let y = (Math.floor(prevLoc5 / 21))-1;
                if (prevLoc5) binInputs[inputBufferChannels * (19 * y + x) + 11] = 1.0;
              }
            }
          }
        }
      }  
      enableLadders(binInputs);
      return binInputs;
    }
    
    async function playMove(button) {
      if (typeof(document) != 'undefined') {
        if (editMode) { if (button) alert('Please switch to "PLAY" mode first'); return; }
      }
      try {
        const binInputs = inputTensor();
        const positionTensor = tf.tensor2d([binInputs], [1, inputFeatures]);
        const policyTensor = model.predict(positionTensor);
        const policyArray = await policyTensor.array();
        const flatPolicyArray = policyArray[0];
        const topPolicies = flatPolicyArray
            .map((v, i) => ({ value: v, index: i }))
            .sort((a, b) => b.value - a.value)
            .map(obj => obj.index);
        positionTensor.dispose();
        policyTensor.dispose();
        for (let move = 0; move < topPolicies.length; move++) {
          let best_19 = topPolicies[move];
          let row_19 = Math.floor(best_19 / 19);
          let col_19 = best_19 % 19;
          let cmknetColor = side == BLACK ? 'Black' : 'White';
          let playerColor = (3-side) == BLACK ? 'Black' : 'White';
          if (typeof(document) != 'undefined') {
            document.getElementById('stats').innerHTML = 'Japanese rules, Komi 6.5';
          }
          let bestMove = 21 * (row_19+1) + (col_19+1);
          if (!setStone(bestMove, side, false)) {
            if (typeof(document) != 'undefined') { alert('Pass'); }
            else console.log('= PASS\n');
            passMove();
            break;
          }
          if (typeof(document) != 'undefined') { drawBoard(); moveSound.play(); }
          else console.log('= ' + 'ABCDEFGHJKLMNOPQRST'[col_19] + (size-row_19-2) + '\n');
          break;
        }
      } catch (e) {console.log(e);}
    }
    
    function initGoban() {
      clearBoard();
      moveHistory.push({
        'ply': 0,
        'side': BLACK,
        'move': EMPTY,
        'board': JSON.stringify(board),
        'ko': ko
      });
      moveCount = moveHistory.length-1;
    }
    
    if (typeof(module) != 'undefined') {
      module.exports = {
        BLACK, WHITE,
        size,
        inputTensor,
        loadSgf,
        loadSgfMove,
        getHistory,
        firstMove,
        lastMove,
        initGoban,
        printBoard,
        setStone,
        playMove,
        passMove
      };
    }
  </script>
</body>
</html>
